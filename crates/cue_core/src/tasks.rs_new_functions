/// Validate task dependencies don't create cycles
pub fn validate_task_dependencies(
    workspace_root: &Path,
    task_id: &str,
    new_deps: &[String],
) -> Result<()> {
    use crate::task_graph::TaskGraph;

    // Build current task graph
    let mut graph = TaskGraph::from_workspace(workspace_root)?;

    // Simulate adding new dependencies
    for dep_id in new_deps {
        // Check if would create cycle
        if graph.would_create_cycle(task_id, dep_id) {
            return Err(CueError::CircularDependency(format!(
                "{} -> {}",
                task_id, dep_id
            )));
        }

        // Check if dependency exists
        let dep_path = workspace_root
            .join(".cuedeck/cards")
            .join(format!("{}.md", dep_id));
        if !dep_path.exists() {
            return Err(CueError::DependencyNotFound(dep_id.clone()));
        }

        // Add temporarily to check next dependency
        graph.add_dependency(task_id, dep_id)?;
    }

    Ok(())
}

/// Get task dependencies
pub fn get_task_dependencies(
    workspace_root: &Path,
    task_id: &str,
) -> Result<Vec<cue_common::TaskDependency>> {
    use crate::task_graph::TaskGraph;

    let graph = TaskGraph::from_workspace(workspace_root)?;
    let deps = graph.get_dependencies(task_id);

    Ok(deps
        .into_iter()
        .map(|to_id| cue_common::TaskDependency {
            from_id: task_id.to_string(),
            to_id,
        })
        .collect())
}

/// Get tasks that depend on this task (reverse dependencies)
pub fn get_task_dependents(
    workspace_root: &Path,
    task_id: &str,
) -> Result<Vec<cue_common::TaskDependency>> {
    use crate::task_graph::TaskGraph;

    let graph = TaskGraph::from_workspace(workspace_root)?;
    let dependents = graph.get_dependents(task_id);

    Ok(dependents
        .into_iter()
        .map(|from_id| cue_common::TaskDependency {
            from_id,
            to_id: task_id.to_string(),
        })
        .collect())
}
